const express = require('express');
const router = express.Router();
const fs = require('fs');
const path = require('path');

// File-based persistence for orders
const ordersFilePath = path.join(__dirname, '..', 'saved-orders.json');

// Load orders from file on startup
let memoryOrders = [];
try {
  if (fs.existsSync(ordersFilePath)) {
    const savedOrders = fs.readFileSync(ordersFilePath, 'utf8');
    memoryOrders = JSON.parse(savedOrders);
    console.log(`Loaded ${memoryOrders.length} previously created orders from file`);
  }
} catch (error) {
  console.log('Could not load saved orders:', error.message);
  memoryOrders = [];
}

// Function to save orders to file
const saveOrdersToFile = () => {
  try {
    fs.writeFileSync(ordersFilePath, JSON.stringify(memoryOrders, null, 2));
    console.log(`Saved ${memoryOrders.length} orders to file`);
  } catch (error) {
    console.error('Error saving orders to file:', error.message);
  }
};

// Use Supabase for persistent order storage

// POST /api/orders - Create a new order (from payment completion)
router.post('/', async (req, res) => {
  try {
    const supabase = req.supabase;
    const { 
      productName, 
      productImage, 
      price, 
      paymentMethod, 
      userId = 'demo-user',
      quantity = 1
    } = req.body;

    // Generate order ID and number
    const orderId = Date.now();
    const orderNumber = `ORD-${orderId}`;
    
    // Create new order object for Supabase
    const orderData = {
      id: orderId,
      orderNumber,
      productName,
      productImage: productImage || '/uploads/solar.jpg',
      price: parseFloat(price),
      quantity,
      totalAmount: parseFloat(price) * quantity,
      paymentMethod,
      orderDate: new Date().toISOString(),
      deliveryDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(), // 5 days from now
      status: 'Reviewing',
      statusSteps: JSON.stringify([
        { label: 'Reviewing', completed: true },
        { label: 'Processing', completed: false },
        { label: 'Shipping', completed: false },
        { label: 'Delivered', completed: false },
      ]),
      userId,
      buyerId: 'buyer-new-' + Date.now(),
      buyerName: 'New Customer',
      buyerEmail: 'customer@example.com'
      // Note: createdAt removed as it may not exist in Supabase table
    };

    try {
      // Save to Supabase database - use flexible approach for existing schema
      const supabaseOrderData = {
        id: orderId,
        orderNumber,
        productName,
        price: parseFloat(price),
        status: 'Reviewing',
        statusSteps: JSON.stringify([
          { label: 'Reviewing', completed: true },
          { label: 'Processing', completed: false },
          { label: 'Shipping', completed: false },
          { label: 'Delivered', completed: false },
        ])
        // Only include basic fields that are most likely to exist
      };

      const { data, error } = await supabase.from('orders').insert([supabaseOrderData]).select();
      if (error) throw error;
      
      console.log('Order saved to Supabase database:', data[0]);
      
      // Transform database response back to frontend format
      const savedOrder = {
        id: data[0].id,
        orderNumber: data[0].orderNumber || data[0].order_number || data[0].id,
        productName: data[0].productName || data[0].product_name || productName,
        productImage: productImage || '/uploads/solar.jpg',
        price: data[0].price || parseFloat(price),
        quantity: quantity,
        totalAmount: parseFloat(price) * quantity,
        paymentMethod: paymentMethod,
        orderDate: data[0].orderDate || data[0].order_date || data[0].created_at || new Date().toISOString(),
        deliveryDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(),
        status: data[0].status,
        statusSteps: JSON.parse(data[0].statusSteps || data[0].status_steps || '[]'),
        userId: userId,
        buyerId: 'buyer-new-' + Date.now(),
        buyerName: 'New Customer',
        buyerEmail: 'customer@example.com',
        paymentStatus: 'Paid',
        createdAt: data[0].created_at || data[0].createdAt || new Date().toISOString()
      };
      
      res.status(201).json({
        success: true,
        order: savedOrder,
        message: 'Order created and saved to database successfully'
      });
      
    } catch (supabaseError) {
      console.log('Supabase order creation failed, using memory storage:', supabaseError.message);
      
      // Fallback: Add to memory storage if Supabase fails
      const memoryOrder = {
        ...orderData,
        statusSteps: [
          { label: 'Reviewing', completed: true },
          { label: 'Processing', completed: false },
          { label: 'Shipping', completed: false },
          { label: 'Delivered', completed: false },
        ]
      };
      
      memoryOrders.push(memoryOrder);
      saveOrdersToFile(); // Persist to file
      console.log('Order saved to memory:', memoryOrder);
      
      res.status(201).json({
        success: true,
        order: memoryOrder,
        message: 'Order created successfully (saved to memory - database schema mismatch)'
      });
    }

  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({
      error: 'Failed to create order',
      details: error.message
    });
  }
});

// GET /api/orders - Get all orders for a user
router.get('/', async (req, res) => {
  try {
    console.log(`API Request: GET /api/orders with userId=${req.query.userId}`);
    console.log(`Current memory orders count: ${memoryOrders.length}`);
    
    const supabase = req.supabase;
    
    try {
      // Try to fetch orders from Supabase - use flexible column ordering
      let orders = [];
      let fetchError = null;
      
      // Strategy 1: Try ordering by created_at (most common)
      try {
        const { data, error } = await supabase
          .from('orders')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (!error) {
          orders = data;
          console.log('✅ Fetched from Supabase using created_at:', data.length, 'orders');
        } else {
          throw error;
        }
      } catch (err) {
        console.log('⚠️ created_at ordering failed:', err.message);
        
        // Strategy 2: Try ordering by order_date
        try {
          const { data, error } = await supabase
            .from('orders')
            .select('*')
            .order('order_date', { ascending: false });
          
          if (!error) {
            orders = data;
            console.log('✅ Fetched from Supabase using order_date:', data.length, 'orders');
          } else {
            throw error;
          }
        } catch (err2) {
          console.log('⚠️ order_date ordering failed:', err2.message);
          
          // Strategy 3: Try simple select without ordering
          try {
            const { data, error } = await supabase
              .from('orders')
              .select('*');
            
            if (!error) {
              orders = data;
              console.log('✅ Fetched from Supabase without ordering:', data.length, 'orders');
            } else {
              throw error;
            }
          } catch (err3) {
            console.log('❌ All Supabase fetch strategies failed:', err3.message);
            fetchError = err3;
          }
        }
      }
      
      if (fetchError) {
        throw fetchError;
      }
        
      // Transform Supabase data to match frontend expectations
      const supabaseOrders = orders.map(order => ({
          id: order.id,
          orderNumber: order.order_number || order.orderNumber || order.id,
          productName: order.product_name || order.productName || 'Product',
          productImage: order.product_image || order.productImage,
          price: order.price || 0,
          quantity: order.quantity || 1,
          totalAmount: order.total_amount || order.totalAmount || order.price || 0,
          paymentMethod: order.payment_method || order.paymentMethod,
          orderDate: order.order_date || order.orderDate || order.created_at,
          deliveryDate: order.delivery_date || order.deliveryDate,
          status: order.status || 'Reviewing',
          statusSteps: JSON.parse(order.status_steps || order.statusSteps || '[]'),
          userId: order.user_id || order.userId || 'demo-user',
          buyerId: order.buyer_id || order.buyerId,
          buyerName: order.buyer_name || order.buyerName || 'Customer',
          buyerEmail: order.buyer_email || order.buyerEmail || 'customer@example.com',
          buyerPhone: order.buyer_phone || order.buyerPhone,
          buyerAddress: order.buyer_address || order.buyerAddress,
          sellerId: order.seller_id || order.sellerId,
          sellerName: order.seller_name || order.sellerName,
          trackingNumber: order.tracking_number || order.trackingNumber,
          carrier: order.carrier,
          paymentStatus: order.payment_status || order.paymentStatus || 'Paid',
          notes: order.notes,
          deliveredAt: order.delivered_at || order.deliveredAt,
          createdAt: order.created_at || order.createdAt,
          updatedAt: order.updated_at || order.updatedAt
        }));
        
        // Combine Supabase orders with memory orders
        const allOrders = [...supabaseOrders, ...memoryOrders];
        
        // Filter by userId if provided
        let filteredOrders = allOrders;
        if (req.query.userId) {
          filteredOrders = allOrders.filter(order => 
            order.userId === req.query.userId
          );
        }
        
        // Sort by order date (newest first)
        filteredOrders.sort((a, b) => {
          const dateA = new Date(a.orderDate || a.createdAt);
          const dateB = new Date(b.orderDate || b.createdAt);
          return dateB - dateA;
        });
        
        console.log(`Returning ${filteredOrders.length} orders (${supabaseOrders.length} from DB, ${memoryOrders.length} from memory)`);
        res.json(filteredOrders);
        
      } catch (orderError) {
        // If ordering by created_at fails, try ordering by id
        console.log('Failed to order by created_at, trying id:', orderError.message);
        const { data, error } = await query.order('id', { ascending: false });
        if (error) throw error;
        
        console.log('Successfully fetched from Supabase using id:', data.length, 'orders');
        
        // Transform with minimal fields that definitely exist
        const supabaseOrders = data.map(order => ({
          id: order.id,
          orderNumber: order.orderNumber || order.id,
          productName: order.productName || 'Product',
          productImage: order.productImage,
          price: order.price || 0,
          quantity: order.quantity || 1,
          totalAmount: order.totalAmount || order.price || 0,
          paymentMethod: order.paymentMethod,
          orderDate: order.orderDate || new Date(order.id).toISOString(),
          deliveryDate: order.deliveryDate,
          status: order.status || 'Reviewing',
          statusSteps: JSON.parse(order.statusSteps || '[]'),
          userId: order.userId || 'demo-user',
          buyerId: order.buyerId,
          buyerName: order.buyerName || 'Customer',
          buyerEmail: order.buyerEmail || 'customer@example.com',
          createdAt: order.createdAt || new Date(order.id).toISOString()
        }));
        
        const allOrders = [...supabaseOrders, ...memoryOrders];
        let filteredOrders = allOrders;
        if (req.query.userId) {
          filteredOrders = allOrders.filter(order => order.userId === req.query.userId);
        }
        
        filteredOrders.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        
        console.log(`Returning ${filteredOrders.length} orders (${supabaseOrders.length} from DB, ${memoryOrders.length} from memory)`);
        res.json(filteredOrders);
      }
      
    } catch (supabaseError) {
      console.log('Supabase orders fetch failed, returning memory orders only:', supabaseError.message);
      
      // Return only real orders from memory (no mock orders)
      let filteredOrders = memoryOrders;
      if (req.query.userId) {
        filteredOrders = memoryOrders.filter(order => order.userId === req.query.userId);
      }
      
      // Sort by creation date (newest first)
      filteredOrders.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
      
      console.log(`Returning ${filteredOrders.length} orders from memory only`);
      res.json(filteredOrders);
    }
  } catch (err) {
    console.error('Orders fetch error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get a single order by ID
router.get('/:id', async (req, res) => {
  try {
    const supabase = req.supabase;
    
    try {
      const { data, error } = await supabase.from('orders').select('*').eq('id', req.params.id).single();
      if (error || !data) throw new Error('Order not found');
      data.statusSteps = JSON.parse(data.statusSteps || '[]');
      res.json(data);
    } catch (supabaseError) {
      console.log('Supabase single order fetch failed, returning mock order:', supabaseError.message);
      // Return mock order for development
      const mockOrder = {
        id: parseInt(req.params.id),
        orderNumber: `ORD-${Date.now()}`,
        productName: 'Solar Panel System',
        productImage: '/uploads/solar.jpg',
        price: 1299.99,
        orderDate: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
        deliveryDate: new Date(Date.now() + 4 * 24 * 60 * 60 * 1000).toISOString(),
        status: 'Processing',
        statusSteps: [
          { label: 'Reviewing', completed: true },
          { label: 'Processing', completed: true },
          { label: 'Shipping', completed: false },
          { label: 'Delivered', completed: false },
        ],
        userId: 'demo-user',
        createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
      };
      res.json(mockOrder);
    }
  } catch (err) {
    console.error('Single order fetch error:', err);
    res.status(404).json({ error: 'Order not found' });
  }
});

// Update order status and details
router.patch('/:id', async (req, res) => {
  try {
    const supabase = req.supabase;
    const { 
      status, 
      paymentStatus, 
      trackingNumber, 
      carrier, 
      notes, 
      deliveredAt 
    } = req.body;
    
    const orderId = req.params.id;
    
    try {
      // First check memory orders
      const memoryOrderIndex = memoryOrders.findIndex(order => order.id == orderId || order.orderNumber === orderId);
      
      if (memoryOrderIndex !== -1) {
        // Update memory order
        const updatedFields = {};
        if (status) updatedFields.status = status;
        if (paymentStatus) updatedFields.paymentStatus = paymentStatus;
        if (trackingNumber) updatedFields.trackingNumber = trackingNumber;
        if (carrier) updatedFields.carrier = carrier;
        if (notes) updatedFields.notes = notes;
        if (deliveredAt) updatedFields.deliveredAt = deliveredAt;
        
        // Update status steps based on status
        if (status) {
          updatedFields.statusSteps = [
            { label: 'Reviewing', completed: true },
            { label: 'Processing', completed: ['Processing', 'Shipped', 'Delivered'].includes(status) },
            { label: 'Shipping', completed: ['Shipped', 'Delivered'].includes(status) },
            { label: 'Delivered', completed: status === 'Delivered' },
          ];
        }
        
        memoryOrders[memoryOrderIndex] = {
          ...memoryOrders[memoryOrderIndex],
          ...updatedFields,
          updatedAt: new Date().toISOString()
        };
        
        console.log('Updated memory order:', memoryOrders[memoryOrderIndex]);
        return res.json(memoryOrders[memoryOrderIndex]);
      }
      
      // Try Supabase update with proper column names
      const { data: order, error: fetchError } = await supabase
        .from('orders')
        .select('*')
        .eq('id', orderId)
        .single();
        
      if (fetchError || !order) {
        return res.status(404).json({ error: 'Order not found' });
      }
      
      let statusSteps = JSON.parse(order.status_steps || '[]');
      const updateData = {};
      
      if (status) {
        updateData.status = status;
        statusSteps = [
          { label: 'Reviewing', completed: true },
          { label: 'Processing', completed: ['Processing', 'Shipped', 'Delivered'].includes(status) },
          { label: 'Shipping', completed: ['Shipped', 'Delivered'].includes(status) },
          { label: 'Delivered', completed: status === 'Delivered' },
        ];
        updateData.status_steps = JSON.stringify(statusSteps);
      }
      
      if (paymentStatus) updateData.payment_status = paymentStatus;
      if (trackingNumber) updateData.tracking_number = trackingNumber;
      if (carrier) updateData.carrier = carrier;
      if (notes) updateData.notes = notes;
      if (deliveredAt) updateData.delivered_at = deliveredAt;
      
      const { data: updated, error: updateError } = await supabase
        .from('orders')
        .update(updateData)
        .eq('id', orderId)
        .select();
        
      if (updateError) throw updateError;
      
      // Transform database response back to frontend format
      const updatedOrder = {
        id: updated[0].id,
        orderNumber: updated[0].order_number,
        productName: updated[0].product_name,
        productImage: updated[0].product_image,
        price: updated[0].price,
        quantity: updated[0].quantity,
        totalAmount: updated[0].total_amount,
        paymentMethod: updated[0].payment_method,
        orderDate: updated[0].order_date,
        deliveryDate: updated[0].delivery_date,
        status: updated[0].status,
        statusSteps: statusSteps,
        userId: updated[0].user_id,
        buyerId: updated[0].buyer_id,
        buyerName: updated[0].buyer_name,
        buyerEmail: updated[0].buyer_email,
        paymentStatus: updated[0].payment_status,
        trackingNumber: updated[0].tracking_number,
        carrier: updated[0].carrier,
        notes: updated[0].notes,
        deliveredAt: updated[0].delivered_at,
        createdAt: updated[0].created_at,
        updatedAt: updated[0].updated_at
      };
      
      console.log('Updated Supabase order:', updatedOrder);
      res.json(updatedOrder);
      
    } catch (supabaseError) {
      console.log('Supabase order update failed:', supabaseError.message);
      res.status(500).json({ error: 'Failed to update order' });
    }
  } catch (err) {
    console.error('Order update error:', err);
    res.status(500).json({ error: err.message });
  }
});

// Legacy endpoint for backward compatibility
router.patch('/:id/status', async (req, res) => {
  // Redirect to the main PATCH endpoint
  req.body = { status: req.body.status };
  return router.patch('/:id')(req, res);
});

module.exports = router;
